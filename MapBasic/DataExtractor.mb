'* DataExtractor is a MapInfo tool to extract biodiversity information
'* from SQL Server and MapInfo GIS layer for pre-defined spatial areas.
'*
'* Copyright © 2012 - 2018 TVERC, GiGL, SBIC
'* 
'* This file is part of the MapInfo tool 'DataExtractor'.
'* 
'* DataExtractor is free software: you can redistribute it and/or modify
'* it under the terms of the GNU General Public License as published by
'* the Free Software Foundation, either version 3 of the License, or
'* (at your option) any later version.
'* 
'* DataExtractor is distributed in the hope that it will be useful,
'* but WITHOUT ANY WARRANTY; without even the implied warranty of
'* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'* GNU General Public License for more details.
'* 
'* You should have received a copy of the GNU General Public License
'* along with DataExtractor.  If not, see <http://www.gnu.org/licenses/>.
'*
'***************************************************************
'* DataExtractor v1.5.23
'*
'* Creates a dialog window which lists the partners in the
'* partner GIS table and also the SQL tables and
'* MapInfo habitat tables and allows the user to select
'* which partners and which tables to process.
'*
'*
'* Created:			Andy Foy - November 2012
'* Last revised:		Andy Foy - December 2018
'*
'* *****************  Version 1.5.23  ***************
'* Author: Andy Foy		Date: 13/12/2018
'* A. Fix parameter bug calling AFSelectSppRecords.
'* B. Use schema when calling stored procedures.
'*
'* *****************  Version 1.5.22  ***************
'* Author: Andy Foy		Date: 29/10/2018
'* A. Get partner layer spatial column name and pass
'*    to SQL stored procedure.
'* B. Add option to use centroids for polygons.
'*
'* *****************  Version 1.5.21  ***************
'* Author: Andy Foy		Date: 22/10/2018
'* A. Include new tool buttons for MI Pro 64bit.
'*
'* *****************  Version 1.5.20  ***************
'* Author: Andy Foy		Date: 03/05/2018
'* A. Try to avoid file locking issues in Windows 10.
'* B. Avoid loop after error processing a partner.
'*
'* *****************  Version 1.5.19  ***************
'* Author: Andy Foy		Date: 27/04/2018
'* A. Reset list value positions before processing to
'*    to avoid entries being missed.
'*
'* *****************  Version 1.5.18  ***************
'* Author: Andy Foy		Date: 28/03/2018
'* A. Reduce maximum process array size to avoid crash.
'*
'* *****************  Version 1.5.17  ***************
'* Author: Andy Foy		Date: 01/12/2017
'* A. Increase max partners to 999 and max processes
'*    to 32,767 (the array limit).
'* B. Truncate temporary table names to 31 chars.
'*
'* *****************  Version 1.5.16  ***************
'* Author: Andy Foy		Date: 30/11/2017
'* A. Truncate user ID if it means the temporary SQL
'*    will be too long for the MapCatalog (> 32 chars).
'*
'* *****************  Version 1.5.15  ***************
'* Author: Andy Foy		Date: 16/11/2017
'* A. Improve debug logging.
'* B. Remove CRs, LFs and tabs from where clauses.
'*
'* *****************  Version 1.5.14  ***************
'* Author: Andy Foy		Date: 09/08/2017
'* A. Force universal translator to generate 2D instead
'*	   of 3D shapefiles.
'*
'* *****************  Version 1.5.13  ***************
'* Author: Andy Foy		Date: 01/05/2017
'* A. Split files into separate columns.
'* B. Fix bug with map tables not being closed when
'*    empty.
'* C. Display file node and table name in map tables
'*    list.
'*
'* *****************  Version 1.5.12  ***************
'* Author: Andy Foy		Date: 25/01/2017
'* A. Remove hard-coded check for 'GRPrecision' column,
'*    enable symbology clauses to be blank.
'*
'* *****************  Version 1.5.11  ***************
'* Author: Andy Foy		Date: 13/07/2016
'* A. Get path and command for universal translator from
'*    config file and pass to sub-routine.
'*
'* *****************  Version 1.5.10  ***************
'* Author: Andy Foy		Date: 11/07/2016
'* A. Enable separate instances for tool to run under
'*    different names in Tool menu.
'*
'* *****************  Version 1.5.9  ****************
'* Author: Andy Foy		Date: 30/05/2016
'* A. Change version number to 3 parts.
'*
'* *****************  Version 1.58  *****************
'* Author: Andy Foy		Date: 05/04/2016
'* A. Fix premature disconnection error when dialog
'*    remains open.
'* B. Revert to original SQL store procedure.
'* C. Save TXT files as comma-separated files.
'* D. Add where clause option to Map tables.
'*
'* *****************  Version 1.57  *****************
'* Author: Andy Foy		Date: 09/03/2016
'* A. Ask user if they want to keep the dialog open.
'* B. Open log file using Notepad.exe.
'* 
'* *****************  Version 1.56  *****************
'* Author: Andy Foy		Date: 22/02/2016
'* A. Enable export of tables in either CSV or TXT
'*    format.
'* B. Hide dialog checkbox options if default values
'*    are blank.
'* 
'* *****************  Version 1.55  *****************
'* Author: Andy Foy		Date: 17/01/2016
'* A. Load active partner details from MapInfo .tab
'*    file instead of SQL Server table.
'* B. Count list of tables not already open in MapInfo.
'* C. Perform user input checks before closing dialog.
'* D. Fix incorrect call to TranslateToShapefile
'*    function for Map tables.
'* 
'* *****************  Version 1.54  *****************
'* Author: Andy Foy		Date: 08/12/2015
'* A. Pass tags column to SQL stored procedure to also
'*    select records based on their survey tags.
'*
'* *****************  Version 1.53  *****************
'* Author: Andy Foy		Date: 11/09/2015
'* A. Call new SQL stored procedures to create and
'*    clear selected subset tables.
'* B. Check if result contains spatial data.
'* C. Improved performance for setting symbology.
'* D. Display numbers with thousand separators in log.
'* E. Make log file user-specific to avoid concurrent
'*    use problems/over-writes.
'* 
'* *****************  Version 1.52  *****************
'* Author: Andy Foy		Date: 08/06/2015
'* A. Added userid to temporary SQL table name to enable
'*	concurrent use of tool.
'* 
'* *****************  Version 1.51  *****************
'* Author: Andy Foy		Date: 01/1/2012
'* A. Initial version of code based.
'* 
'***************************************************************
Include "DataExtractor.def"

Sub Main
'***************************************************************
'* Main sub-routine
'***************************************************************

	OnError Goto HandleError

	'-------------------------------------------------
	' Set the version number
	'-------------------------------------------------
	sVersion = "1.5.23"

	'-------------------------------------------------
	' Get the title for the Tool menu
	'-------------------------------------------------
	Call GetToolTitle

	Call CreateToolMenu(sToolTitle)
	
	Exit Sub

HandleError:
	Note "Main: " + Error$()
	Resume Next

End Sub

Sub GetToolTitle
'***************************************************************
'* Retrieve the tool title to use from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode

	OnError Goto GetTitleError

	' Set the default Tool menu title
	sToolTitle = "Data Extractor"

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + "DataExtractor.xml", bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataExtractor node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataExtractor")
	          	If hXMLNode Then
	
					'-------------------------------------------------
					' Load the default values from the child nodes
					' under the DataExtractor node
					'-------------------------------------------------
					' Title for adding the program to the Tool menu
					Dim sTitle As String
					sTitle = GetSingleNodeValue(hXMLNode, "ToolTitle")
					If sTitle <> "" Then
						sToolTitle = sTitle
					End If

				End If

			End If

		Else

			Goto GetTitleError

		End If

	End If

CleanUp:
	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetTitleError:
	Note "Unable to get tool title from XML config file.  Using default title 'Data Extractor'."
	Exit Sub

End Sub

Sub GetDefaultValues
'***************************************************************
'* Retrieve all the default values from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode
	Dim hXMLFilesNodeList As MIXMLNodeList
	Dim hXMLFilesNodeParent As MIXmlNode
	Dim hXMLFilesNode As MIXmlNode

	OnError Goto GetVariablesError

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + "DataExtractor.xml", bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataExtractor node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataExtractor")
	          	If hXMLNode Then
	
					'-------------------------------------------------
					' Load the default values from the child nodes
					' under the DataExtractor node
					'-------------------------------------------------
					' File path for for storing the log file
					Dim sLogFilePath As string
					sLogFilePath = GetSingleNodeValue(hXMLNode, "LogFilePath")
					sLogFileName = sLogFilePath & "\DataExtractor_" & sUserID & ".log"

					' File DSN path and name containing remote SQL database connection settings
					sFileDSN = GetSingleNodeValue(hXMLNode, "FileDSN")

					' Default file path to store extracts in sub-folders
					sDefaultPath = GetSingleNodeValue(hXMLNode, "DefaultPath")

					' Default database schema to use in the remote SQL database
					sDefaultSchema = GetSingleNodeValue(hXMLNode, "DatabaseSchema")

					' Name of partner table in the remote SQL database
					sPartnerTable = GetSingleNodeValue(hXMLNode, "PartnerTable")

					' Name of column of partner names in the partner table
					sPartnerColumn = GetSingleNodeValue(hXMLNode, "PartnerColumn")

					' Name of column of partner abbreviations in the partner table
					sShortColumn = GetSingleNodeValue(hXMLNode, "ShortColumn")

					' Name of column of partner notes in the partner table
					sNotesColumn = GetSingleNodeValue(hXMLNode, "NotesColumn")

					' Name of column of active partner flag in the partner table
					sActiveColumn = GetSingleNodeValue(hXMLNode, "ActiveColumn")

					' Name of column of GIS format in the partner table
					sFormatColumn = GetSingleNodeValue(hXMLNode, "FormatColumn")

					' Name of column of Export to text format in the partner table
					sExportColumn = GetSingleNodeValue(hXMLNode, "ExportColumn")

					' Name of column of SQL Files list in the partner table
					sSQLFilesColumn = GetSingleNodeValue(hXMLNode, "SQLFilesColumn")

					' Name of column of Map Files list in the partner table
					sMapFilesColumn = GetSingleNodeValue(hXMLNode, "MapFilesColumn")

					' Name of column of Tags list in the partner table
					sTagsColumn = GetSingleNodeValue(hXMLNode, "TagsColumn")

					' Name of column of spatial geometry in the partner table
					sSpatialColumn = GetSingleNodeValue(hXMLNode, "SpatialColumn")

					' The options for the selection types
					sSelectTypeOptions = GetSingleNodeValue(hXMLNode, "SelectTypeOptions")

					' Default selection type (1 = spatial, 2 = tags, 3 = both)
					iDefaultSelectType = GetSingleNodeValue(hXMLNode, "DefaultSelectType")

					' SQL used to list the names of SQL tables in the remote SQL database
					sTableListSQL = GetSingleNodeValue(hXMLNode, "TableListSQL")

					' Maximum number of records to be downloaded at one time
					iRecMax = GetSingleNodeValue(hXMLNode, "RecMax")

					' Default setting for zipping extract files
					sDefaultZip = GetSingleNodeValue(hXMLNode, "DefaultZip")

					' SQL clause for excluding confidential surveys
					sConfidentialClause = GetSingleNodeValue(hXMLNode, "ConfidentialClause")

					' Default setting for extracting confidential surveys
					sDefaultConfidential = GetSingleNodeValue(hXMLNode, "DefaultConfidential")

					' Path to universal translator program
					sUTPath = GetSingleNodeValue(hXMLNode, "UTPath")

					' Command for running universal translator program
					sUTCommand = GetSingleNodeValue(hXMLNode, "UTCommand")

					'-------------------------------------------------
					' Get a handle on the SQLTables node
					'-------------------------------------------------
					hXMLFilesNodeParent = MIXmlSelectSingleNode(hXMLNode, "SQLTables")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLFilesNodeList = MIXMLGetChildList(hXMLFilesNodeParent)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' storing the columns and SQL clauses in arrays
					'-------------------------------------------------
					Dim i As Integer
					i = 0
					Redim SQLFiles(99)
					Do while hXMLFilesNode
						
						i = i + 1

						' Name of the table node
						SQLFiles(i).Node = GetNodeName(hXMLFilesNode)

						' Name of the MapInfo table to be created
						SQLFiles(i).TableName = GetSingleNodeValue(hXMLFilesNode, "TableName")

						' SQL statement used to retrieve the required columns from the temporary SQL table
						SQLFiles(i).Columns = GetSingleNodeValue(hXMLFilesNode, "Columns")

						' SQL clause used to retrieve the required rows from the temporary SQL table
						SQLFiles(i).Clauses = GetSingleNodeValue(hXMLFilesNode, "Clauses")
						
						' Remove CR, LF and Tab chars
						SQLFiles(i).Clauses = StringReplace(SQLFiles(i).Clauses, chr$(10), "")
						SQLFiles(i).Clauses = StringReplace(SQLFiles(i).Clauses, chr$(13), "")
						SQLFiles(i).Clauses = StringReplace(SQLFiles(i).Clauses, chr$(9), "")

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)
					Loop

					Redim SQLFiles(i)

					'-------------------------------------------------
					' Get a handle on the MapTables node
					'-------------------------------------------------
					hXMLFilesNodeParent = MIXmlSelectSingleNode(hXMLNode, "MapTables")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLFilesNodeList = MIXMLGetChildList(hXMLFilesNodeParent)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' storing the table names and columns and in arrays
					'-------------------------------------------------
					i = 0
					Redim AllMaps(99)
					Do while hXMLFilesNode
						
						i = i + 1

						' Name of the Map node
						AllMaps(i).Node = GetNodeName(hXMLFilesNode)

						' Name of the MapInfo input and output Map table
						AllMaps(i).TableName = GetSingleNodeValue(hXMLFilesNode, "TableName")

						' SQL statement used to retrieve the required rows from the loaded map table
						AllMaps(i).Columns = GetSingleNodeValue(hXMLFilesNode, "Columns")

						' SQL clause used to retrieve the required rows from the loaded map table
						AllMaps(i).Clauses = GetSingleNodeValue(hXMLFilesNode, "Clause")

						' Remove CR, LF and Tab chars
						AllMaps(i).Clauses = StringReplace(AllMaps(i).Clauses, chr$(10), "")
						AllMaps(i).Clauses = StringReplace(AllMaps(i).Clauses, chr$(13), "")
						AllMaps(i).Clauses = StringReplace(AllMaps(i).Clauses, chr$(9), "")

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLFilesNode = MIXMLGetNextNode(hXMLFilesNodeList)
					Loop

					Redim AllMaps(i)

				End If

			End If

		Else

			Note "Error opening XML config file 'DataExtractor.xml'."

		End If

	End If

	'-------------------------------------------------
	' Build the SQL used to list the partner names
	' from the partner MapInfo table
	'-------------------------------------------------
	sPartnerListSQL = "Select " + sPartnerColumn + ", " + sShortColumn + ", " + sNotesColumn + ", " + sFormatColumn + ", " + sExportColumn + ", " + sSQLFilesColumn +  ", " + sMapFilesColumn + 
		" From " + sPartnerTable +
		" Where " + sActiveColumn + " = " + Chr$(34) + "Y" + Chr$(34) + " Or " + sActiveColumn + " = " + Chr$(34) + "y" + Chr$(34) + 
		" Order By " + sPartnerColumn +
		" Into PartnerList NoSelect"

CleanUp:
	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLFilesNode Then Call MIXmlNodeDestroy(hXMLFilesNode) End If
	If hXMLFilesNodeList Then Call MIXmlNodeListDestroy(hXMLFilesNodeList) End If
	If hXMLFilesNodeParent Then Call MIXmlNodeDestroy(hXMLFilesNodeParent) End If
	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetVariablesError:
	Note str$(Err()) + ": " + Error$()
	Exit Sub

End Sub

Sub DataExtractor
'***************************************************************
'* Create the user dialog window
'***************************************************************

	'-------------------------------------------------
	' Trap errors
	'-------------------------------------------------
    OnError Goto ErrorTrap

	'-------------------------------------------------
	' Get the current user ID
	'-------------------------------------------------
	sUserID = GetUserID()
	sUserID = StringReplace(sUserID, " ", "_")
	sUserID = StringReplace(sUserID, ".", "_")

	'-------------------------------------------------
	' Retrieve the default values from the config file
	'-------------------------------------------------
	Call GetDefaultValues

	'-------------------------------------------------
	' Build a new dialog window
	'-------------------------------------------------
	Dialog
		Title "Data Extractor " + sVersion
		Width 370
		Height 270
		Position 50, 70
		Calling DialogSetup

	'-------------------------------------------------
	' Add a partner listbox
	'-------------------------------------------------
	Control StaticText Title "Active Partners:"
		Position 10, 10
	Control MultiListBox
		ID 1
		Title ""
		Position 10, 20
		Height 180
		Width 170
		Calling PartnerList_Handler

	'-------------------------------------------------
	' Add a SQL table listbox
	'-------------------------------------------------
	Control StaticText Title "SQL Tables:"
		Position 190, 10
	Control MultiListBox
		ID 2
		Title ""
		Position 190, 20
		Height 40
		Width 170

	'-------------------------------------------------
	' Add a MapInfo table listbox
	'-------------------------------------------------
	Control StaticText Title "MapInfo Tables:"
		Position 190, 70
	Control MultiListBox
		ID 3
		Title ""
		Position 190, 80
		Height 120
		Width 170

	'-------------------------------------------------
	' Add a checkbox for zipping the extract files
	'-------------------------------------------------
	Control CheckBox
		ID 4
		Title "Zip extract files?"
		Position 10,210
		Value FALSE
		'Into bZipFiles

	'-------------------------------------------------
	' Add a checkbox for extract confidential surveys
	'-------------------------------------------------
	Control CheckBox
		ID 5
		Title "Extract confidential surveys?"
		Position 10,225
		Value FALSE
		'Into bConfidentialSurveys

	'-------------------------------------------------
	' Add a checkbox for clearing the log file
	'-------------------------------------------------
	Control CheckBox
		ID 6
		Title "Clear log file?"
		Position 10,240
		Value FALSE
		'Into bClearLog

	'-------------------------------------------------
	' Add a checkbox for selecting polygons by centroids
	'-------------------------------------------------
	Control CheckBox
		ID 7
		Title "Select polygons by centroids?"
		Position 10,255
		Value FALSE
		'Into bUseCentroids

	'-------------------------------------------------
	' Add a popup menu for picking the select type
	'-------------------------------------------------
	Control StaticText Title "Selection Type:"
		Position 190,210
	Control PopupMenu
		ID 10
		Value iDefaultSelectType
		Title From Variable sSelectTypeOptions
		Position 190,220
		Width 170
		'Into iSelectType

	'-------------------------------------------------
	' Add Ok and cancel buttons
	'-------------------------------------------------
	Control CancelButton
		Position 275,250
		Width 40
	Control Button
		Title "Ok"
		Position 320,250
		Width 40
		Calling CheckSelection

Done:
	Exit Sub
	
ErrorTrap:
	Note str$(Err()) + ": " + Error$()
	Call MyPrint("Error: " + str$(Err()) + " - " + Error$())
	Resume Done

End Sub

Sub DialogSetup
'***************************************************************
' Setup the dialog window listboxes
'***************************************************************

	'-------------------------------------------------
	' Clear the Message window and close it
	'-------------------------------------------------
	Print(chr$(12))
	Close Window Message

	'-------------------------------------------------
	' Trap any connection errors
	'-------------------------------------------------
	OnError Goto ConnectionError

	'-------------------------------------------------
	' Connect to the SQL Server database
	'-------------------------------------------------
	nConn = Server_Connect("ODBC","FILEDSN=" + sFileDSN)
	If nConn = 0 Then
		Note "Error: Unable to connect to SQL Server!"
		Call egsit
	End If 

	'-------------------------------------------------
	' No longer trap any errors
	'-------------------------------------------------
	OnError Goto 0

	'-------------------------------------------------
	' Check the partner table is already open in
	' MapInfo
	'-------------------------------------------------
	If Not TableIsOpen(sPartnerTable) Then
		Note "Error: Table '" + sPartnerTable + "' is not open."
		Goto SetDefaults
	End If

	'-------------------------------------------------
	' Query all the Partners in the boundary table
	'-------------------------------------------------
	Run Command (sPartnerListSQL)

	'-------------------------------------------------
	' Count the number of rows selected
	'-------------------------------------------------
	Dim iPartners As Integer
	iPartners = TableInfo("PartnerList", TAB_INFO_NROWS)

	'-------------------------------------------------
	' If any rows were selected then load the columns
	'-------------------------------------------------
	If iPartners > 0 Then

		'-------------------------------------------------
		' Fetch the first of the selected rows
		'-------------------------------------------------
		Fetch First from PartnerList

		Dim sPartner, sShort, sNote, sFormat, sExport, sSQLFiles, sMapFiles As String

		'-------------------------------------------------
		' Loop through all the partners in the partners
		' table and add them to the Partners list
		'-------------------------------------------------
		Dim i as integer
		i = 0
		Redim PartnersList(999)
		Redim Partners(999)
		While i < iPartners
	
			i = i + 1

			'-------------------------------------------------
			' Concatenate all the partners into an array
			'-------------------------------------------------
			PartnersList(i) = PartnerList.Col1
			Partners(i).Name = PartnerList.Col1
			Partners(i).Short = LTrim$(RTrim$(Str$(PartnerList.Col2)))
			Partners(i).Notes = LTrim$(RTrim$(Str$(PartnerList.Col3)))
			Partners(i).Formats = PartnerList.Col4
			Partners(i).Exports = PartnerList.Col5
			Partners(i).SQLFiles = PartnerList.Col6
			Partners(i).MapFiles = PartnerList.Col7

			Fetch Next from PartnerList
	
		Wend

		Redim PartnersList(i)
		Redim Partners(i)
		
		'-------------------------------------------------
		' Close the list of Partners
		'-------------------------------------------------
		Close Table PartnerList

	End If

	'-------------------------------------------------
	' Update the Partner list to show the list of partners
	'-------------------------------------------------
	Alter Control 1 Title FROM Variable PartnersList

	'-------------------------------------------------
	' Query all the tables in the database
	'-------------------------------------------------
	Dim nStmt as Integer
	nStmt = Server_Execute(nConn, sTableListSQL)

	'-------------------------------------------------
	' Bind to the 1st column of the results
	'-------------------------------------------------
	Dim sSQLTable As String
	Dim iStatus As Integer
	Server nStmt Bind Column 1 To sSQLTable, iStatus
	Server nStmt Fetch Next

	'-------------------------------------------------
	' Loop through all the SQL tables matching the
	' SQL criteria and add them to the SQL Tables list
	'-------------------------------------------------
	i = 0
	Redim SQLTablesList(99)
	While Not Server_Eot(nStmt)

		'-------------------------------------------------
		' Concatenate all the SQL tables into an array
		'-------------------------------------------------
		i = i + 1
		SQLTablesList(i) = sSQLTable
		Server nStmt Fetch Next

	Wend

	Redim SQLTablesList(i)

	'-------------------------------------------------
	' Close the query results
	'-------------------------------------------------
	Server nStmt Close

	'-------------------------------------------------
	' Update the SQL Table list to show the list
	' of tables
	'-------------------------------------------------
	Alter Control 2 Title FROM Variable SQLTablesList

	'-------------------------------------------------
	' Store the names of any tables not open
	'-------------------------------------------------
	Dim sClosedTables As String, iClosedCount as Integer
	sClosedTables = ""
	iClosedCount = 0
	
	'-------------------------------------------------
	' Loop through all the MapInfo tables listed in the
	' config file and add them to the Map Tables list
	' if they are open in MapInfo
	'-------------------------------------------------
	Dim j As Integer
	j = 0
	Redim OpenMaps(99)
	Redim OpenMapsList(99)
	For i = 1 to UBound(AllMaps)

		'-------------------------------------------------
		' Concatenate all the Map tables into an array
		'-------------------------------------------------
		If TableIsOpen(AllMaps(i).TableName) Then
			j = j + 1
			OpenMapsList(j) = AllMaps(i).Node + " ---> " + AllMaps(i).TableName
			OpenMaps(j).Node = AllMaps(i).Node
			OpenMaps(j).TableName = AllMaps(i).TableName
			OpenMaps(j).Columns = AllMaps(i).Columns
			OpenMaps(j).Clauses = AllMaps(i).Clauses
		Else
			'-------------------------------------------------
			' Store the name of the closed table
			'-------------------------------------------------
			sClosedTables = sClosedTables + Chr$(13) + AllMaps(i).TableName
			iClosedCount = iClosedCount + 1
		End If

	Next

	Redim OpenMaps(j)
	Redim OpenMapsList(j)

	'-------------------------------------------------
	' Warn the user of the closed tables
	'-------------------------------------------------
	If iClosedCount > 0 Then
		If iClosedCount = 1 Then
			Note "Warning: the following table is not open ..." + Chr$(13) + sClosedTables
		Else
			Note "Warning: " + iClosedCount + " tables are not open, including ..." + Chr$(13)+ sClosedTables
		End If
	End If

	'-------------------------------------------------
	' Update the Map Table list to show the list of tables
	'-------------------------------------------------
	Alter Control 3 Title FROM Variable OpenMapsList

SetDefaults:
	'-------------------------------------------------
	' Set the default value for the zip checkbox
	'-------------------------------------------------
	If UCase$(sDefaultZip) = "YES" OR UCase$(sDefaultZip) = "Y" Then
		Alter Control 4 Value TRUE
	Else
		Alter Control 4 Value FALSE
	End If

	'-------------------------------------------------
	' Hide the zip checkbox if no default set
	'-------------------------------------------------
	If sDefaultZip = "" Then
		Alter Control 4 Hide
	End If

	'-------------------------------------------------
	' Set the default value for the extract
	' confidential surveys checkbox
	'-------------------------------------------------
	If UCase$(sDefaultConfidential) = "YES" OR UCase$(sDefaultConfidential) = "Y" Then
		Alter Control 5 Value TRUE
	Else
		Alter Control 5 Value FALSE
	End If

	'-------------------------------------------------
	' Hide the confidential surveys checkbox if no
	' default set
	'-------------------------------------------------
	If sDefaultConfidential = "" Then
		Alter Control 5 Hide
	End If

	'-------------------------------------------------
	' Set the default value for the select polygons
	' by centroids checkbox
	'-------------------------------------------------
	If UCase$(sDefaultUseCentroids) = "YES" OR UCase$(sDefaultUseCentroids) = "Y" Then
		Alter Control 7 Value TRUE
	Else
		Alter Control 7 Value FALSE
	End If

	'-------------------------------------------------
	' Hide the select polygons by centroid checkbox
	' if no default set
	'-------------------------------------------------
	If sDefaultUseCentroids = "" Then
		Alter Control 7 Hide
	End If

	'-------------------------------------------------
	' Set the default value for the select type
	' popup menu
	'-------------------------------------------------
	Alter Control 10 Value iDefaultSelectType

Exit Sub

ConnectionError:

If Err() = 1333 Then
	Note "Error: Unable to connect to SQL Server!"
'	Call MyPrint("Error: Unable to connect to SQL Server!")
	Call egsit
End If

End Sub

Sub PartnerList_Handler
'***************************************************************
' Called when the Partner list box is clicked or double-clicked
'***************************************************************

	Dim iPartner as Integer
	'-------------------------------------------------
	' If the list is double-clicked then show the notes text
	'-------------------------------------------------
	If CommandInfo(CMD_INFO_DLG_DBL) Then
		iPartner = ReadControlValue(TriggerControl())
		If Partners(iPartner).Notes = "" Then
			Note Partners(iPartner).Name + " (" + Partners(iPartner).Short + ") notes: " + Chr$(10) + Chr$(10) + "None"
		Else
			Note Partners(iPartner).Name + " (" + Partners(iPartner).Short + ") notes: " + Chr$(10) + Chr$(10) + "'" + Partners(iPartner).Notes + "'"
		End If
	End If

End Sub

Sub CheckSelection
'***************************************************************
'* Check the user's selections and process according
'***************************************************************

	'-------------------------------------------------
	' Store the dialog variables
	'-------------------------------------------------
	bZipFiles = ReadControlValue(4)
	bConfidentialSurveys = ReadControlValue(5)
	bClearLog = ReadControlValue(6)
	bUseCentroids = ReadControlValue(7)
	iSelectType = ReadControlValue(10)

	'-------------------------------------------------
	' Check if the user has selected at least one partner
	'-------------------------------------------------
	iPartner = ReadControlValue(1)
	if iPartner = 0 then
		Note "No partners have been selected!"
		Exit Sub
	End If

	'-------------------------------------------------
	' Check if the user has selected at least one table
	' from either of the table lists
	'-------------------------------------------------
	iSQLTable = ReadControlValue(2)
	iMapTable = ReadControlValue(3)
	if iSQLTable = 0 And iMapTable = 0 then
		Note "No tables have been selected!"
		Exit Sub
	End If

	'-------------------------------------------------
	' Reset the global variables
	'-------------------------------------------------
	iExtractTot = 0
	iExtractCnt = 0
	sLastShortName = ""

	'-------------------------------------------------
	' Reset the lists
	'-------------------------------------------------
	iPartner = ReadControlValue(1)
	Do Until iPartner = 0
	   iPartner = ReadControlValue(1)
	Loop

	iSQLTable = ReadControlValue(2)
	Do Until iSQLTable = 0
	   iSQLTable = ReadControlValue(2)
	Loop

	iMapTable = ReadControlValue(3)
	Do Until iMapTable = 0
	   iMapTable = ReadControlValue(3)
	Loop

	'-------------------------------------------------
	' Read the first list values
	'-------------------------------------------------
	iPartner = ReadControlValue(1)
	iSQLTable = ReadControlValue(2)
	iMapTable = ReadControlValue(3)

	'-------------------------------------------------
	' Count the number of extracts to run
	'-------------------------------------------------
	Redim ProcessSelected(25000)
	Do While iPartner > 0
		Do While iSQLTable > 0
			'-------------------------------------------------
			' Increment the counter
			'-------------------------------------------------
			iExtractTot = iExtractTot + 1

			ProcessSelected(iExtractTot).Node = ""
			ProcessSelected(iExtractTot).TableName = SQLTablesList(iSQLTable)
			ProcessSelected(iExtractTot).TableType = "SQL"
			ProcessSelected(iExtractTot).Partner = Partners(iPartner).Name
			ProcessSelected(iExtractTot).Short = Partners(iPartner).Short
			ProcessSelected(iExtractTot).Formats = Partners(iPartner).Formats
			ProcessSelected(iExtractTot).Exports = Partners(iPartner).Exports
			ProcessSelected(iExtractTot).Files = Partners(iPartner).SQLFiles
			ProcessSelected(iExtractTot).Columns = ""
			ProcessSelected(iExtractTot).Clauses = ""

			'-------------------------------------------------
			' Read the next table selected in the list
			'-------------------------------------------------
			iSQLTable = ReadControlValue(2)
		Loop

		Do While iMapTable > 0
			'-------------------------------------------------
			' Increment the counter
			'-------------------------------------------------
			iExtractTot = iExtractTot + 1

			ProcessSelected(iExtractTot).Node = OpenMaps(iMapTable).Node
			ProcessSelected(iExtractTot).TableName = OpenMaps(iMapTable).TableName
			ProcessSelected(iExtractTot).TableType = "Map"
			ProcessSelected(iExtractTot).Partner = Partners(iPartner).Name
			ProcessSelected(iExtractTot).Short = Partners(iPartner).Short
			ProcessSelected(iExtractTot).Formats = Partners(iPartner).Formats
			ProcessSelected(iExtractTot).Exports = Partners(iPartner).Exports
			ProcessSelected(iExtractTot).Files = Partners(iPartner).MapFiles
			ProcessSelected(iExtractTot).Columns = OpenMaps(iMapTable).Columns
			ProcessSelected(iExtractTot).Clauses = OpenMaps(iMapTable).Clauses

			'-------------------------------------------------
			' Read the next table selected in the list
			'-------------------------------------------------
			iMapTable = ReadControlValue(3)
		Loop

		'Redim ProcessSelected(iExtractTot)

		'-------------------------------------------------
		' Read the next partner selected in the list
		'-------------------------------------------------
		iPartner = ReadControlValue(1)

		'-------------------------------------------------
		' Read the first SQL table selected
		' in the list again
		'-------------------------------------------------
		iSQLTable = ReadControlValue(2)

		'-------------------------------------------------
		' Read the first Map table selected
		' in the list again
		'-------------------------------------------------
		iMapTable = ReadControlValue(3)
	Loop

	'-------------------------------------------------
	' Output options to log file
	'-------------------------------------------------
	If bZipFiles = True Then
		Call MyPrint("Zipping extract files ...")
	Else
		Call MyPrint("Leaving extract files unzipped ...")
	End If
	If bConfidentialSurveys = True Then
		Call MyPrint("Including confidential surveys ...")
	Else
		Call MyPrint("Excluding confidential surveys ...")
	End If
	If bUseCentroids = True Then
		Call MyPrint("Selecting polygons by centroids ...")
	Else
		Call MyPrint("Selecting polygons by geometry ...")
	End If
	Call MyPrint("Performing selection type '" + iSelectType + "' ...")

	'-------------------------------------------------
	' Clear the log file (if it exists)
	'-------------------------------------------------
	If bClearLog = True Then
		If FileExists(sLogFileName) Then
			Kill sLogFileName
		End If

		'-------------------------------------------------
		' Clear the translate to shapefile log file
		' (if it exists)
		'-------------------------------------------------
		Dim sLogFilePath As String, sLogFileShp As String
		sLogFilePath = PathToDirectory$(sLogFileName)
		sLogFileShp = "TabToShp" + "_" + sUserID

		If FileExists(sLogFilePath + "\" + sLogFileShp + "_MUT.log") Then
			Kill sLogFilePath + "\" + sLogFileShp + "_MUT.log"
		End If
	End If

	'-------------------------------------------------
	' Reset the file access error counter
	'-------------------------------------------------
	iFileErrorCount = 0

	Call MyPrint("----------------------------------------------------------------------")
	Call MyPrint("Process started!")
	Call MyPrint("----------------------------------------------------------------------")
	Call MyPrint("")

	'-------------------------------------------------
	' Process the selections one by one
	'-------------------------------------------------
	iExtractCnt = 1
	ProgressBar "Processing " + iExtractTot + " data extracts ..."
		Calling ProcessExtracts
		Range iExtractTot

	'-------------------------------------------------
	' Ask the user if they want to close the form
	'-------------------------------------------------
	Dim lResponse As Logical
	If CommandInfo(CMD_INFO_STATUS) Then
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("Process completed!")
		Call MyPrint("----------------------------------------------------------------------")
		lResponse = Ask("Processing complete!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")
	Else
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("Process interrupted by user!")
		Call MyPrint("----------------------------------------------------------------------")
		lResponse = Ask("Processing interrupted!" + Chr$(10) + Chr$(10) + Chr$(10) + "Do you wish to close the form?", "Yes", "No")
	End If

	If lResponse = True Then
		'-------------------------------------------------
		' Close the dialog
		'-------------------------------------------------
		Dialog Remove

		'-------------------------------------------------
		' Disconnect the connection to the SQL Server database
		'-------------------------------------------------
		Server nConn Disconnect

	End If

	'-------------------------------------------------
	' Display the log file in the message window
	'-------------------------------------------------
	Call PrintLogFile

	'-------------------------------------------------
	' Report the number of file access errors
	'-------------------------------------------------
	If iFileErrorCount > 0 then
		Note "Note: There were " & iFileErrorCount & " file access delays during this process."
	End If

End Sub

Sub ProcessExtracts
'***************************************************************
'* Process each combination of table and partner
'***************************************************************

	OnError Goto ErrorTrap

	Dim sNodeName, sTableName, sTableType, sPartnerName, sShortName, sFormat, sExport, sFiles, sMapColumns, sMapClauses As String
	sNodeName = ProcessSelected(iExtractCnt).Node
	sTableName = ProcessSelected(iExtractCnt).TableName
	sTableType = ProcessSelected(iExtractCnt).TableType
	sPartnerName = ProcessSelected(iExtractCnt).Partner
	sShortName = ProcessSelected(iExtractCnt).Short
	sFormat = ProcessSelected(iExtractCnt).Formats
	sExport = ProcessSelected(iExtractCnt).Exports
	sFiles = ProcessSelected(iExtractCnt).Files
	sMapColumns = ProcessSelected(iExtractCnt).Columns
	sMapClauses = ProcessSelected(iExtractCnt).Clauses

	'-------------------------------------------------
	' If this is a new partner ...
	'-------------------------------------------------
	If sShortName <> sLastShortName and iExtractCnt <> 1 Then

		'-------------------------------------------------
		' Zip up all the extract files for the last
		' partner if required
		'-------------------------------------------------
		If bZipFiles Then
			If ZipFiles(sDefaultPath, sLastShortName) > 1 Then
				Call MyPrint("Error zipping extract files for partner.")
			End If
		End If

		Call MyPrint("Processing for partner complete.")
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("")

	End If
	
	If sShortName <> sLastShortName Then
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("Processing partner '" + sPartnerName + " (" + sShortName + ")' ...")

		'-------------------------------------------------
		' Create the partner subdirectory if it doesn't
		' already exist
		'-------------------------------------------------
		Dim iSuccess, iSecurity As Integer
		Dim sLocalPath As String
		iSecurity = 0
		sLocalPath = sDefaultPath + "\" + sShortName
		iSuccess = SetCurrentDirectory(sLocalPath )
		if iSuccess = 0 Then
			Call MyPrint("Creating sub-directory '" + sLocalPath + "'")
			iSuccess = CreateDirectory(sLocalPath , iSecurity)
			if iSuccess = 0 Then
				Call MyPrint("Error creating sub-directory")
				Call MyPrint("Process terminated.")
				Exit Sub
			End If
		End If

		' Save the last partner short name
		sLastShortName = sShortName
	End If

	Call MyPrint("Starting process " + iExtractCnt + " of " + iExtractTot + " ...")

	'-------------------------------------------------
	' Call the subroutine to select the records from
	' the selected table for the selected partner
	'-------------------------------------------------
	If sTableType = "SQL" Then
		Call SelectSQL(nConn, sPartnerName, sShortName, sFormat, sExport, sFiles, iSelectType, sTableName)
	Else
		Call SelectMaps(sPartnerName, sShortName, sFormat, sExport, sFiles, sNodeName, sTableName, sMapColumns, sMapClauses)
	End If

	Call MyPrint("Completed process " + iExtractCnt + " of " + iExtractTot + ".")
	Call MyPrint("")

	If iExtractCnt = iExtractTot Then

		'-------------------------------------------------
		' Zip up all the extract files for the last
		' partner if required
		'-------------------------------------------------
		If bZipFiles Then
			If ZipFiles(sDefaultPath, sLastShortName) > 1 Then
				Call MyPrint("Error zipping extract files for partner.")
			End If
		End If

		Call MyPrint("Processing for partner complete.")
		Call MyPrint("----------------------------------------------------------------------")
		Call MyPrint("")

	End If
	
	'-------------------------------------------------
	' Increment the progress bar to show progress
	'-------------------------------------------------
	ProgressBar = iExtractCnt

	'-------------------------------------------------
	' Go to the next selection in the list
	'-------------------------------------------------
	iExtractCnt = iExtractCnt + 1
	If iExtractCnt > iExtractTot Then
		'-------------------------------------------------
		' Halt processing
		'-------------------------------------------------
		ProgressBar = -1
	End If

ExitSub:
	Exit Sub
	
ErrorTrap:
	'-------------------------------------------------
	' Halt processing
	'-------------------------------------------------
	ProgressBar = -1

End Sub

Sub SelectSQL (ByVal nConn As Integer,
	sPartnerName As String,
	sShortName As String,
	sFormat As String,
	sExport As String,
	sSQLFiles As String,
	iSelectType As Integer,
	sTableName As String)
'*************************************************
'* Routine to select the records from the
'* SQL table name passed in the call that
'* intersect with the boundaries where the
'* partner equals the value passed in the call.
'*************************************************

	Dim iWaitCount As Integer
	iWaitCount = 0

	Dim ErrorType As String
	ErrorType = ""

	OnError Goto ErrorTrap

	'-------------------------------------------------
	' Get the current user ID
	'-------------------------------------------------
	Dim sUser As String
	sUser = sUserID

	'-------------------------------------------------
	' Truncate the user ID if it will make the
	' temporary SQL table name too long
	'-------------------------------------------------
	If Len(sTableName + "_" + sUser) > 32 Then
		sUser = Left$(sUser, Maximum(31 - Len(sTableName), 0))
	End If

	'-------------------------------------------------
	' Check the partner requires something
	'-------------------------------------------------
	If UCase$(sExport) = "" AND
		((UCase$(sFormat) <> "SHP" And
		UCase$(sFormat) <> "TAB" And
		UCase$(sFormat) <> "BOTH") Or
		sSQLFiles = "") Then
		Call MyPrint("Skipping table = '" + sTableName + "' - not required.")
		Exit Sub
	End If

	Call MyPrint("Processing table = '" + sTableName + "' ...")

	'-------------------------------------------------
	' Set the use centroids parameter
	'-------------------------------------------------
	Dim iUseCentroids As Integer
	If bUseCentroids = True Then
		iUseCentroids = 1
	Else
		iUseCentroids = 0
	End If

	'-------------------------------------------------
	' Execute the SQL Server stored procedure to select
	' the records intersecting with the current
	' partner boundary
	'-------------------------------------------------
	Dim nStmt1 As Integer
	Call MyPrint("Executing spatial selection ...")

	nStmt1 = Server_Execute(nConn, "EXECUTE " + sDefaultSchema + ".AFSelectSppRecords '" + sDefaultSchema
	 + "', '" + sPartnerTable + "', '" + sPartnerColumn + "', '"
	 + sPartnerName + "', '" + sTagsColumn + "', '" + sSpatialColumn + "', " + iSelectType + ", '" + sTableName + "', '" + sUser + "', " + iUseCentroids)

	Call MyPrint("Spatial selection complete.")

	'-------------------------------------------------
	' Close the results
	'-------------------------------------------------
	Server nStmt1 Close

	'-------------------------------------------------
	' Setup the temporary SQL table name
	'-------------------------------------------------
	Dim sSQLTable As String
	sSQLTable = sTableName + "_" + sUser

	'-------------------------------------------------
	' Count the number of records that have been
	' selected
	'-------------------------------------------------
	Dim nStmt2 As Integer
	Dim iRecTotal As Integer
	Dim iRecStatus As Integer
	nStmt2 = Server_Execute(nConn, "Select Count(*) As Records From " + sDefaultSchema + "." + sSQLTable)
	Server nStmt2 Bind Column 1 To iRecTotal, iRecStatus
	Server nStmt2 Fetch Next

	'-------------------------------------------------
	' Check if any records were extracted
	'-------------------------------------------------
	If iRecTotal = 0 Then
		Call MyPrint("No records selected - skipping extracts.")
		Goto CleanUp
	End If

	Call MyPrint("" + FormatNumber$(iRecTotal) + " records selected.")

	'-------------------------------------------------
	' Close the results
	'-------------------------------------------------
	Server nStmt2 Close

	'-------------------------------------------------
	' Loop through all the SQL clauses in the array
	' and create a subset of the temporary table
	' using each clause if the clause name is found
	' in the partner table for this partner
	'-------------------------------------------------
	Dim i As Integer
	Dim sNodeName, sLocalTable as String
	For i = 1 to UBound(SQLFiles)

		'-------------------------------------------------
		' If this SQL clause is found in the partner
		' table record then process it, otherwise skip
		' to the next SQL clause.
		'-------------------------------------------------
		sNodeName = SQLFiles(i).Node
		If Instr(1, Ucase$(sSQLFiles), Ucase$(sNodeName)) > 0 then
			sLocalTable = SQLFiles(i).TableName
		Else
			Goto NextClause
		End If

		'-------------------------------------------------
		' Setup the temporary and local table names
		'-------------------------------------------------
		Dim sLocalPath, sTempTable As String
		sLocalPath = sDefaultPath + "\" + sShortName
		sTempTable = Left$(sLocalTable + "_" + sShortName, 31)

		Call MyPrint("")
		Call MyPrint("Extracting '" + sLocalTable + "' ...")

		'-------------------------------------------------
		' Set the SQL clause, excluding any
		' confidential surveys if they are not required
		'-------------------------------------------------
		Dim sSQLClause As String
		If SQLFiles(i).Clauses = "" Then
			If bConfidentialSurveys = True Or sConfidentialClause = "" Then
				sSQLClause = ""
			Else
				sSQLClause = sConfidentialClause
			End If
		Else
			If bConfidentialSurveys = True Or sConfidentialClause = "" Then
				sSQLClause = SQLFiles(i).Clauses
			Else
				sSQLClause = SQLFiles(i).Clauses & " And " & sConfidentialClause
			End If
		End If

	    If sSQLClause = "" Then
	        Call MyPrint("No where clause was used")
       	Else
			Call MyPrint("Where clause is ... " + sSQLClause)
			sSQLClause = "Where " & sSQLClause
		End If

		'-------------------------------------------------
		' Count the number of records that have been
		' selected in the output temporary table
		'-------------------------------------------------
		nStmt2 = Server_Execute(nConn, "Select Count(*) As Records From " + sDefaultSchema + "." + sSQLTable + " " + sSQLClause)
		Server nStmt2 Bind Column 1 To iRecTotal, iRecStatus
		Server nStmt2 Fetch Next

		'-------------------------------------------------
		' Close the results
		'-------------------------------------------------
		Server nStmt2 Close

		'-------------------------------------------------
		' Check if any records were extracted
		'-------------------------------------------------
		If iRecTotal = 0 Then
			Call MyPrint("No records found - extract skipped.")
			Goto NextClause
		End If

		Call MyPrint("" + FormatNumber$(iRecTotal) + " records to extract.")

		'-------------------------------------------------
		' Check if the maximum number of records will be
		' exceeded
		'-------------------------------------------------
		If iRecTotal > iRecMax Then
			Call MyPrint("Record count exceeds maximum of " + FormatNumber$(iRecMax) + " - extract skipped.")
			Goto NextClause
		End If

		'-------------------------------------------------
		' Check if the temporary table is already/still open
		' and close it if it is
		'-------------------------------------------------
		If TableIsOpen(sTempTable) Then
			Call MyPrint("Closing temporary table ...")
			Close Table sTempTable
		End If

		'-------------------------------------------------
		' Check if the local table is already/still open
		' and close it if it is
		'-------------------------------------------------
		If TableIsOpen(sLocalTable) Then
			Call MyPrint("Closing local table ...")
			Close Table sLocalTable
		End If

		'-------------------------------------------------
		' Set up the SQL statement for creating an empty
		' temporary table (to check the record length)
		'-------------------------------------------------
		Dim sSQLStmt As String
		sSQLStmt = "Select Top(0) " + SQLFiles(i).Columns + " From " + sDefaultSchema + "." + sSQLTable + " " + sSQLClause

		'-------------------------------------------------
		' Link the SQL table as a temporary table
		'-------------------------------------------------
LinkTemp:
		OnError Goto TempError
		
		Call MyPrint("Linking dummy table ...")
		Server nConn Link Table
		sSQLStmt
		Toolkit "ODBC"
		Into sTempTable
		File sLocalPath + "\" + sLocalTable
		Autokey Off
		ReadOnly

		OnError Goto ErrorTrap

		'-------------------------------------------------
		' Get the table name alias of the new table
		'-------------------------------------------------
		Dim sTableAlias As String
		sTableAlias = TableInfo(0, TAB_INFO_NAME)

		'-------------------------------------------------
		' Unlink the temporary table to leave the local
		' table as a regular standalone table
		'-------------------------------------------------
		Call MyPrint("Unlinking dummy table ...")
		Unlink sTableAlias

		'-------------------------------------------------
		' If the table contains a MI_STYLE column
		' then delete the column
		'-------------------------------------------------
		If ColumnExists(sTableAlias, "MI_STYLE") Then
			Alter Table sTableAlias (Drop MI_STYLE)
		End If

		'-------------------------------------------------
		' If the table contains a MI_PRINX column
		' then delete the column
		'-------------------------------------------------
		If ColumnExists(sTableAlias, "MI_PRINX") Then
			Alter Table sTableAlias (Drop MI_PRINX)
		End If

		'-------------------------------------------------
		' Calculate the maximum record length
		'-------------------------------------------------
		Dim iRowLength As Integer
		iRowLength = GetRowLength(sTableAlias)

		'-------------------------------------------------
		' Drop the dummy table
		'-------------------------------------------------
		If TableIsOpen(sTableAlias) Then
			Call MyPrint("Dropping dummy table ...")
			Drop Table sTableAlias
		End If

		'-------------------------------------------------
		' Check if the maximum record length will be exceeded
		'-------------------------------------------------
		If iRowLength > 4096 Then

			Call MyPrint("Record length exceeds maximum of 4,096 bytes - selection cancelled.")
			Note "Record length exceeds maximum of 4,096 bytes - selection cancelled."

			Exit Sub

		Else
			Call MyPrint("Total record length = " + FormatNumber$(iRowLength) + " bytes")
		End If

		'-------------------------------------------------
		' Display the total data size
		'-------------------------------------------------
		Dim iDataSize As Integer
		iDataSize = ((iRowLength * iRecTotal) / 1024) + 1

		If iDataSize > (1024 * 1024) Then
			Call MyPrint("Total data size = " + FormatNumber$(iDataSize) + " Kb (" + FormatNumber$(Round(iDataSize / (1024 * 1024), 0.01)) + " Gb)")
		Else
			If iDataSize > 1024 Then
				Call MyPrint("Total data size = " + FormatNumber$(iDataSize) + " Kb (" + FormatNumber$(Round(iDataSize / 1024, 0.01)) + " Mb)")
			Else
				Call MyPrint("Total data size = " + FormatNumber$(iDataSize) + " Kb")
			End If
		End If

		'-------------------------------------------------
		' Check if the total data size will be exceeded
		'-------------------------------------------------
		If iDataSize > (2*1024*1024) Then

			Call MyPrint("Total data size exceeds maximum of 2 Gb - selection cancelled.")
			Note "Total data size exceeds maximum of 2 Gb - selection cancelled."

			Exit Sub

		End If

		'-------------------------------------------------
		' Set up the SQL statement for extracting from
		' the temporary table
		'-------------------------------------------------
		sSQLStmt = "Select " + SQLFiles(i).Columns + " From " + sDefaultSchema + "." + sSQLTable + " " + sSQLClause

		'-------------------------------------------------
		' Link the SQL table as a temporary table
		'-------------------------------------------------
LinkTable:
		OnError Goto LinkError
		
		Call MyPrint("Linking temporary table ...")
		Server nConn Link Table
		sSQLStmt
		Toolkit "ODBC"
		Into sTempTable
		File sLocalPath + "\" + sLocalTable
		Autokey Off
		ReadOnly

		OnError Goto ErrorTrap

		'-------------------------------------------------
		' Get the table name alias of the new table
		'-------------------------------------------------
		sTableAlias = TableInfo(0, TAB_INFO_NAME)

		'-------------------------------------------------
		' Unlink the temporary table to leave the local
		' table as a regular standalone table
		'-------------------------------------------------
		Call MyPrint("Unlinking temporary table ...")
		Unlink sTableAlias

		'-------------------------------------------------
		' Check if the table contains an Obj column
		' which indicates if there is any spatial data
		'-------------------------------------------------
		Dim bSpatialData As Logical
		bSpatialData = True
		'If ColumnExists(sTableAlias, "Obj") Then
		If Not TableInfo(sTableAlias, TAB_INFO_MAPPABLE) Then
			Call MyPrint("Table does not contain spatial data")
			bSpatialData = False
		End If

		'-------------------------------------------------
		' If the table contains a MI_STYLE column
		' then delete the column
		'-------------------------------------------------
		If ColumnExists(sTableAlias, "MI_STYLE") Then
			Alter Table sTableAlias (Drop MI_STYLE)
		End If

		'-------------------------------------------------
		' If the table contains a MI_PRINX column
		' then delete the column
		'-------------------------------------------------
		If ColumnExists(sTableAlias, "MI_PRINX") Then
			Alter Table sTableAlias (Drop MI_PRINX)
		End If

		'-------------------------------------------------
		' Also export the temporary table as a text file if required
		'-------------------------------------------------
ExportTable:
		OnError Goto ExportError
		
		If UCase$(sExport) = "CSV" Then
			Call MyPrint("Exporting as a CSV ...")

			Set ProgressBars Off

			Export sTableAlias
				Into sLocalPath + "\" + sLocalTable + ".csv"
				Type "ASCII"
				Delimiter ","
				CharSet "WindowsLatin1"
				Titles
				Overwrite

			Set ProgressBars On

		ElseIf UCase$(sExport) = "TXT" Then


			Call MyPrint("Exporting as a TXT ...")

			Set ProgressBars Off

			Export sTableAlias
				Into sLocalPath + "\" + sLocalTable + ".txt"
				Type "ASCII"
				Delimiter ","
				CharSet "WindowsLatin1"
				Titles

				Overwrite

			Set ProgressBars On

		End If

		OnError Goto ErrorTrap

		'-------------------------------------------------
		' Translate the table to ESRI shapefile if required
		'-------------------------------------------------
		If UCase$(sFormat) = "SHP" Or UCase$(sFormat) = "BOTH" Then
			Dim sLogFilePath As String, sLogFileShp As String
			sLogFilePath = PathToDirectory$(sLogFileName)
			sLogFileShp = "TabToShp" + "_" + sUserID

			'Call MyPrint("Log File Path = '" + sLogFilePath + "'")

			Call TranslateToShapefile(sUTPath, sUTCommand, sLogFilePath, sLogFileShp, sLocalPath, sLocalTable)
		End If

		'-------------------------------------------------
		' If the partner requires a MapInfo table
		'-------------------------------------------------
		If UCase$(sFormat) = "TAB" Or UCase$(sFormat) = "BOTH" Then
		
			'-------------------------------------------------
			' Check if the local table is mappable (i.e.
			' contains the 'OBJ' graphics column) and the
			' graphics column contains spatial data
			'-------------------------------------------------
			If TableInfo(sTableAlias, TAB_INFO_MAPPABLE)
			And bSpatialData = True Then

				'-------------------------------------------------
				' Check if the temporary table is open
				'-------------------------------------------------
				If TableIsOpen(sTableAlias) Then

					Call MyPrint("Setting symbology in table ...")

					Set ProgressBars Off

					'-------------------------------------------------
					' Turn on FastEdit to speed up the updates
					'-------------------------------------------------
					Set Table sTableAlias FastEdit On

					'-------------------------------------------------
					' Set the symbology for the table before closing
					'-------------------------------------------------
					Call SetSymbology(sNodeName, sLocalTable, sShortName)

					Dim sCmd As String
					sCmd = "Commit Table " + sTableAlias
					Run Command (sCmd)

					'-------------------------------------------------
					' Turn FastEdit off once updates are done
					'-------------------------------------------------
					Set Table sTableAlias FastEdit Off

					Call MyPrint("Closing the MapInfo table ...")
					Close Table sTableAlias

				End If

			End If
		Else
			'-------------------------------------------------
			' If the partner doesn't require a MapInfo table
			' check if the local table is open and drop it
			'-------------------------------------------------
			If TableIsOpen(sTableAlias) Then
				Call MyPrint("Dropping the MapInfo table ...")
				Drop Table sTableAlias
			End If
		End If

	'-------------------------------------------------
	' Process the next SQL clause
	'-------------------------------------------------
NextClause:
	Next

	'-------------------------------------------------
	' Execute a SQL Server stored procedure to delete
	' the temporary SQL table
	'-------------------------------------------------
CleanUp:
	Dim nStmt3 As Integer
	nStmt3 = Server_Execute(nConn, "EXECUTE " + sDefaultSchema + ".AFClearSppSubset '" + sDefaultSchema
	+ "', '" + sTableName + "', '" + sUser + "'")

	'-------------------------------------------------
	' Close the results
	'-------------------------------------------------
	Server nStmt3 Close

ExitSub:

	If iWaitCount > 0 Then
		iFileErrorCount = iFileErrorCount + 1
	End If

	Exit Sub

TempError:
	ErrorType = "Temp"	
	Goto ErrorTrap

LinkError:
	ErrorType = "Link"	
	Goto ErrorTrap

ExportError:
	ErrorType = "Export"	
	Goto ErrorTrap

ErrorTrap:

	'-------------------------------------------------
	' Exit if we've already waited 20 seconds
	'-------------------------------------------------
	If iWaitCount > 20 Then
		Note str$(Err()) + ": " + Error$()
		Call MyPrint("Error: " + str$(Err()) + " - " + Error$())
		Goto ExitSub
	End If

	'-------------------------------------------------
	' If this is a file access error then wait 
	' for 5 seconds and then try again
	'-------------------------------------------------
	If Left$(Error$(), 18) = "Cannot access file" Then
		Call Wait(5)
		iWaitCount = iWaitCount + 5
		
		Do Case ErrorType
			Case "Temp"
				Call MyPrint("Error: " + str$(Err()) + " - linking temporary table " + sTempTable)
				Resume LinkTemp
			Case "Link"
				Call MyPrint("Error: " + str$(Err()) + " - linking table " + sTempTable)
				Resume LinkTable
			Case "Export"
				Call MyPrint("Error: " + str$(Err()) + " - exporting records from " + sTableAlias + " into " + sLocalTable)
				Resume ExportTable
		End Case
	Else
		Note str$(Err()) + ": " + Error$()
		Call MyPrint("Error: " + str$(Err()) + " - " + Error$())
		Goto ExitSub
	End If

End Sub

Sub SetSymbology(sNodeName as String, sLocalTable As String, sShortName As String)
'***************************************************************
'* Retrieve the symbology styles and clauses from the config file
'* which is a XML document
'***************************************************************

	Dim bParseError As SmallInt
	Dim hXMLDoc As MIXmlDocument
	Dim hXMLRoot As MIXmlNode
	Dim hXMLNode As MIXmlNode
	Dim hXMLSQLTableNode As MIXmlNode
	Dim hXMLTableNode As MIXmlNode
	Dim hXMLSymbologyNode As MIXmlNode
	Dim hXMLSymbolNodeList As MIXMLNodeList
	Dim hXMLSymbolNode As MIXmlNode

	OnError Goto GetSymbologyError

	'-------------------------------------------------
	' Setup the temporary and local table names
	'-------------------------------------------------
	Dim sTempTable As String
	sTempTable = Left$(sLocalTable + "_" + sShortName, 31)

	'-------------------------------------------------
	' Create a document handle
	'-------------------------------------------------
	hXMLDoc = MIXmlDocumentCreate()
	If hXMLDoc Then

		'-------------------------------------------------
		' Load the document into the document handle
		'-------------------------------------------------
		Dim iXMLLoad As SmallInt
		iXMLLoad = MIXmlDocumentLoad(hXMLDoc, ApplicationDirectory$() + "DataExtractor.xml", bParseError, FALSE, FALSE)
		if iXMLLoad > 0 Then

			'-------------------------------------------------
			' Get a handle on the XML root node of the document
			'-------------------------------------------------
			hXMLRoot = MIXmlDocumentGetRootNode(hXMLDoc)
			If hXMLRoot Then

				'-------------------------------------------------
				' Get a handle on the DataExtractor node
				'-------------------------------------------------
				hXMLNode = MIXmlSelectSingleNode(hXMLRoot, "DataExtractor")
	          	If hXMLNode Then
	
					'-------------------------------------------------
					' Get a handle on the SQLTables node
					'-------------------------------------------------
					hXMLSQLTableNode = MIXmlSelectSingleNode(hXMLNode, "SQLTables")

					'-------------------------------------------------
					' Get a handle on the current SQL table node
					'-------------------------------------------------
					hXMLTableNode = MIXmlSelectSingleNode(hXMLSQLTableNode, sNodeName)

					'-------------------------------------------------
					' Get a handle on the symbology node for the table
					'-------------------------------------------------
					hXMLSymbologyNode = MIXmlSelectSingleNode(hXMLTableNode, "Symbology")

					'-------------------------------------------------
					' Get a handle on the node map of the above node
					'-------------------------------------------------
					hXMLSymbolNodeList = MIXMLGetChildList(hXMLSymbologyNode)

					'-------------------------------------------------
					' Get a handle on the first attribute in the node list
					'-------------------------------------------------
					hXMLSymbolNode = MIXMLGetNextNode(hXMLSymbolNodeList)

					'-------------------------------------------------
					' Loop through all the attributes in the node list
					' applying the style using the SQL clauses
					'-------------------------------------------------
					Dim i As Integer
					i = 0
					Do while hXMLSymbolNode
						
						'-------------------------------------------------
						' Close the temporary NewStyle table if it is
						' already/still open in the current MapInfo session
						'-------------------------------------------------
						If TableIsOpen("NewStyle") Then
							Close Table NewStyle
						End If

						i = i + 1

						'-------------------------------------------------
						' Set the SQL clause used to retrieve the
						' required rows from the SQL table
						'-------------------------------------------------
						Dim sClause As String
						sClause = GetSingleNodeValue(hXMLSymbolNode, "Clause")
						Dim sSQLClause As String
						sSQLClause = sClause
						If sSQLClause <> "" Then
							sSQLClause = " And " & sClause
						End If

						'-------------------------------------------------
						' Get the type of object (i.e. Point or Region)
						'-------------------------------------------------
						Dim sObject As String
						sObject = GetSingleNodeValue(hXMLSymbolNode, "Object")

						'-------------------------------------------------
						' Select all the rows of the desired object type
						' matching the required SQL clause
						'-------------------------------------------------
						Dim sCmd As String
						sCmd = "Select * From " + sTempTable + " Where Str$(obj) = """ + sObject + """ " + sSQLClause + " Into NewStyle NoSelect"
						Run Command (sCmd)

						'-------------------------------------------------
						' Count the number of rows selected
						'-------------------------------------------------
						Dim iRows As Integer
						iRows = TableInfo(NewStyle, TAB_INFO_NROWS)

						Call MyPrint("Setting " + sObject + " style for " + FormatNumber$(iRows) + " rows where ... " + sClause)

						'-------------------------------------------------
						' If any rows were selected then set the styles
						'-------------------------------------------------
						If iRows > 0 Then

							'-------------------------------------------------
							' Set the styles (depending on type of object)
							'-------------------------------------------------
							Dim sSymbol, sPen, sBrush As String
							Dim stlSymbol As Symbol
							Dim stlPen As Pen
							Dim stlBrush As Brush

							Do Case sObject
								Case "Point"
									sSymbol = GetSingleNodeValue(hXMLSymbolNode, "Symbol")
									stlSymbol = STLText2Symbol(sSymbol)
								Case "Region"
									sPen = GetSingleNodeValue(hXMLSymbolNode, "Pen")
									stlPen = STLText2Pen(sPen)
									sBrush = GetSingleNodeValue(hXMLSymbolNode, "Brush")
									stlBrush = STLText2Brush(sBrush)
								Case Else
							End Case

							'-------------------------------------------------
							' Alter the object style depending on the object
							' type and style type
							'-------------------------------------------------
							Do Case sObject
								Case "Point"
									Update NewStyle Set Obj = SetStylePoint(Obj, stlSymbol)
								Case "Region"
									Update NewStyle Set Obj = SetStylePolygon(Obj, stlPen, stlBrush)
								Case Else
							End Case

						End If

						'-------------------------------------------------
						' Get a handle on the next attribute in the node list
						'-------------------------------------------------
						hXMLSymbolNode = MIXMLGetNextNode(hXMLSymbolNodeList)

					Loop

				End If

			End If

		Else

			Note "Error : " + MIGetErrorMessage()

		End If

	End If

CleanUp:
	'-------------------------------------------------
	' Destroy the handles
	'-------------------------------------------------
	If hXMLSymbolNode Then Call MIXmlNodeDestroy(hXMLSymbolNode) End If
	If hXMLSymbolNodeList Then Call MIXmlNodeListDestroy(hXMLSymbolNodeList) End If
	If hXMLSymbologyNode Then Call MIXmlNodeDestroy(hXMLSymbologyNode) End If
	If hXMLTableNode Then Call MIXmlNodeDestroy(hXMLTableNode) End If

	If hXMLSQLTableNode Then Call MIXmlNodeDestroy(hXMLSQLTableNode) End If
	If hXMLNode Then Call MIXmlNodeDestroy(hXMLNode) End If
	If hXMLRoot Then Call MIXmlNodeDestroy(hXMLRoot) End If
	If hXMLDoc Then Call MIXmlDocumentDestroy(hXMLDoc) End If

	Exit Sub

GetSymbologyError:
	Note str$(Err()) + ": " + Error$()
	Exit Sub

End Sub

Function SetStylePoint(ByVal oObj As Object, ByVal stlSymbol As Symbol) As Object

	Alter Object oObj Info OBJ_INFO_SYMBOL, stlSymbol
	SetStylePoint = oObj

End Function

Function SetStylePolygon(ByVal oObj As Object, ByVal stlPen As Pen, ByVal stlBrush As Brush) As Object

	Alter Object oObj Info OBJ_INFO_PEN, stlPen
	Alter Object oObj Info OBJ_INFO_BRUSH, stlBrush
	SetStylePolygon = oObj

End Function

Sub SelectMaps (sPartnerName As String,
	sShortName As String,
	sFormat As String,
	sExport As String,
	sMapFiles As String,
	sNodeName as String,
	sTableName As String,
	sMapColumns As String,
	sMapClauses As String)
'*************************************************
'* Routine to select the records from the
'* MapInfo table name passed in the call that
'* intersect with the boundaries where the
'* partner equals the value passed in the call.
'*************************************************

	Dim iWaitCount As Integer
	iWaitCount = 0

	Dim ErrorType As String
	ErrorType = ""

	OnError Goto ErrorTrap

	'-------------------------------------------------
	' Check the partner requires something
	'-------------------------------------------------
	If UCase$(sExport) = "" And
		((UCase$(sFormat) <> "SHP" And
		UCase$(sFormat) <> "TAB" And
		UCase$(sFormat) <> "BOTH") Or
		sMapFiles = "") Then
		Call MyPrint("Skipping table = '" + sTableName + "' - not required.")
		Exit Sub
	End If

	'-------------------------------------------------
	' If this Map table is found in the partner
	' table record then process it, otherwise skip it
	'-------------------------------------------------
	If Instr(1, Ucase$(sMapFiles), Ucase$(sNodeName)) = 0 then
		Call MyPrint("Skipping table = '" + sTableName + "' - not required.")
		Exit Sub
	End If

	Call MyPrint("Processing table = '" + sTableName + "' ...")

	'-------------------------------------------------
	' Setup the temporary and local table names
	'-------------------------------------------------
	Dim sLocalPath, sLocalTable, sTempTable As String
	sLocalPath = sDefaultPath + "\" + sShortName
	sLocalTable = sTableName
	sTempTable = Left$(sTableName + "_" + sShortName, 31)

	'-------------------------------------------------
	' Check if the local table is already/still open
	' and close it if it is
	'-------------------------------------------------
	If TableIsOpen(sTempTable) Then
		Call MyPrint("Closing temporary table ...")
		Close Table sTempTable
	End If

	'-------------------------------------------------
	' Execute the SQL statement to select the table
	' records intersecting with the required
	' partner boundary
	'-------------------------------------------------
	Call MyPrint("Executing spatial selection ...")
	Dim sCmd As String
	Dim sWhereClause As string
	If sMapClauses = "" Then
		sWhereClause = ""
	Else
		sWhereClause = " And " + sMapClauses
	End If
	
SelectRecords:
	OnError Goto SelectError
	
	sCmd = "Select " + sMapColumns + " From " + sTableName + " Where obj Intersects (Select obj From " + sPartnerTable + " Where Str$(" + sShortColumn + ") = " + Chr$(34) + sShortName + Chr$(34) + ") " + sWhereClause + " Into " + sTempTable + " NoSelect"
	Run Command (sCmd)

	OnError Goto ErrorTrap

	'-------------------------------------------------
	' Count the number of records that have
	' been selected
	'-------------------------------------------------
	Dim iRecTotal As Integer
	iRecTotal = TableInfo(sTempTable, TAB_INFO_NROWS)

	'-------------------------------------------------
	' Check if the maximum number of records will be
	' exceeded
	'-------------------------------------------------
	If iRecTotal > iRecMax Then
		Call MyPrint("Record count exceeds maximum of " + iRecMax + " - extract skipped.")
		If TableIsOpen(sTempTable) Then
			Call MyPrint("Closing the MapInfo table ...")
			Close Table sTempTable
		End If
		Exit Sub
	End If

	'-------------------------------------------------
	' Check if any records were extracted
	'-------------------------------------------------
	If iRecTotal = 0 Then
		Call MyPrint("No records found - extract skipped.")
		If TableIsOpen(sTempTable) Then
			Call MyPrint("Closing the MapInfo table ...")
			Close Table sTempTable
		End If
		Exit Sub
	End If

	Call MyPrint("" + FormatNumber$(iRecTotal) + " records selected.")

	'-------------------------------------------------
	' Save the local table
	'-------------------------------------------------
	Call MyPrint("Saving temporary table ...")

SaveTable:
	OnError Goto SaveError
	
	sCmd = "Commit Table " + sTempTable + " As " + Chr$(34) + sLocalPath + "\" + sLocalTable + ".tab" + Chr$(34) + " TYPE NATIVE Charset " + Chr$(34) + "WindowsLatin1" + Chr$(34)
	Run Command (sCmd)

	OnError Goto ErrorTrap

	'-------------------------------------------------
	' Close the local table and re-open it (as it seems
	' to get locked somehow and won't drop)
	'-------------------------------------------------
	Close Table sTempTable

OpenTable:
	OnError Goto OpenError
	
	sCmd = "Open Table " + Chr$(34) + sLocalPath + "\" + sLocalTable + ".tab" + Chr$(34) + " As " + sTempTable
	Run Command (sCmd)

ExportTable:
	OnError Goto ExportError
	
	'-------------------------------------------------
	' Also export the table as a text file if required
	'-------------------------------------------------
		If UCase$(sExport) = "CSV" Then
			Call MyPrint("Exporting as a CSV ...")

			Set ProgressBars Off

			Export sTempTable
				Into sLocalPath + "\" + sLocalTable + ".csv"
				Type "ASCII"
				Delimiter ","
				CharSet "WindowsLatin1"
				Titles
				Overwrite

			Set ProgressBars On

		ElseIf UCase$(sExport) = "TXT" Then
			Call MyPrint("Exporting as a TXT ...")

			Set ProgressBars Off

			Export sTempTable
				Into sLocalPath + "\" + sLocalTable + ".txt"
				Type "ASCII"
				Delimiter ","
				CharSet "WindowsLatin1"
				Titles
				Overwrite

			Set ProgressBars On

		End If

	OnError Goto ErrorTrap

	'-------------------------------------------------
	' Translate the table to ESRI shapefile if required
	'-------------------------------------------------
	If UCase$(sFormat) = "SHP" Or UCase$(sFormat) = "BOTH" Then
		Dim sLogFilePath As String, sLogFileShp As String
		sLogFilePath = PathToDirectory$(sLogFileName)
		sLogFileShp = "TabToShp" + "_" + sUserID

		Call TranslateToShapefile(sUTPath, sUTCommand, sLogFilePath, sLogFileShp, sLocalPath, sLocalTable)
	End If

	'-------------------------------------------------
	' If the partner requires a MapInfo table
	'-------------------------------------------------
	If UCase$(sFormat) = "TAB" Or UCase$(sFormat) = "BOTH" Then
		'-------------------------------------------------
		' Check if the local table is open and close it
		'-------------------------------------------------
		If TableIsOpen(sTempTable) Then
			Call MyPrint("Closing the MapInfo table ...")
			Close Table sTempTable
		End If
	Else
		'-------------------------------------------------
		' If the partner doesn't require a MapInfo table
		' drop (delete) the table
		'-------------------------------------------------
		If TableIsOpen(sTempTable) Then
			Call MyPrint("Dropping the MapInfo table ...")
			Drop Table sTempTable
		End If
	End If

ExitSub:

	If iWaitCount > 0 Then
		iFileErrorCount = iFileErrorCount + 1
	End If

	Exit Sub

SelectError:
	ErrorType = "Select"	
	Goto ErrorTrap

SaveError:
	ErrorType = "Save"	
	Goto ErrorTrap

OpenError:
	ErrorType = "Open"	
	Goto ErrorTrap

ExportError:
	ErrorType = "Export"	
	Goto ErrorTrap

ErrorTrap:


	'-------------------------------------------------
	' Exit if we've already waited 20 seconds
	'-------------------------------------------------
	If iWaitCount > 20 Then
		Note str$(Err()) + ": " + Error$()
		Call MyPrint("Error: " + str$(Err()) + " - " + Error$())
		Goto ExitSub
	End If

	'-------------------------------------------------
	' If this is a file access error then wait 
	' for 1 second and then try again
	'-------------------------------------------------
	If Left$(Error$(), 18) = "Cannot access file" Then
		Call Wait(5)
		iWaitCount = iWaitCount + 5
		
		Do Case ErrorType
			Case "Select"
				Call MyPrint("Error: " + str$(Err()) + " - selecting records into " + sTempTable)
				Resume SelectRecords
			Case "Save"
				Call MyPrint("Error: " + str$(Err()) + " - saving table " + sTempTable)
				Resume SaveTable
			Case "Open"
				Call MyPrint("Error: " + str$(Err()) + " - opening table " + sTempTable)
				Resume OpenTable
			Case "Export"
				Call MyPrint("Error: " + str$(Err()) + " - exporting records from " + sTempTable + " into " + sLocalTable)
				Resume ExportTable
		End Case
	Else
		Note str$(Err()) + ": " + Error$()
		Call MyPrint("Error: " + str$(Err()) + " - " + Error$())
		Goto ExitSub
	End If

End Sub

Sub AboutBox
'***************************************************************
'* Display the 'About' dialog box
'***************************************************************

	Dialog
		Title "About Data Extractor " + sVersion
		Width 230
		Height 115

	Control StaticText
		Title "This program will extract SQL records and/or GIS"
		Position 10,10
	Control StaticText
		Title "layers that intersect with partner boundary feature(s)."
		Position 10,20
	Control StaticText
		Title "The user can select which SQL table or GIS layers"
		Position 10,30
	Control StaticText
		Title "to extract and which partner boundaries to extract for."
		Position 10,40
	Control StaticText
		Title "Created by Andy Foy Consulting."
		Position 10,60
	Control StaticText
		Title "Copyright© 2012 - 2018 GiGL, TVERC, SBIC."
		Position 10,70
	Control OKButton
		Position 185,95

End Sub

Sub MyPrint(ByVal sMsg As String)
'***************************************************************
'* Bespoke print function
'***************************************************************

	Dim iWaitCount As Integer
	iWaitCount = 0

	'-------------------------------------------------
	' Trap any print errors
	'-------------------------------------------------
	OnError Goto OpenError

OpenLog:
	'-------------------------------------------------
	' Open the log file for output
	'-------------------------------------------------
	Open File sLogFileName For Append As #1

	'-------------------------------------------------
	' Write the message passed to the output file
	'-------------------------------------------------
	Print #1, FormatDate$(CurDate()) + " " + FormatTime$(CurTime(),"H:mm:ss") + " : " + sMsg

	'-------------------------------------------------
	' Close the output file
	'-------------------------------------------------
	Close File #1

ExitSub:

	If iWaitCount > 0 Then
		iFileErrorCount = iFileErrorCount + 1
	End If

	Exit Sub

OpenError:

	'-------------------------------------------------
	' Exit if we've already waited 5 seconds
	'-------------------------------------------------
	If iWaitCount > 5 Then
		Note str$(Err()) + ": " + Error$()
		Goto ExitSub
	End If

	'-------------------------------------------------
	' If this is a file access error then wait 
	' for 1 second and then try again
	'-------------------------------------------------
	If Left$(Error$(), 18) = "Cannot access file" Then
		Call Wait(1)
		iWaitCount = iWaitCount + 1
		Resume OpenLog
	Else
		Note str$(Err()) + ": " + Error$()
	End If

End Sub

Sub PrintLogFile()
'***************************************************************
'* Open the log file in Notepad
'***************************************************************

	'-------------------------------------------------
	' Open the log file in Notepad
	'-------------------------------------------------
	Dim sCmd As String
	sCmd = "Run Program " +  + Chr$(34) + "NotePad.exe " + sLogFileName + Chr$(34)
	Run Command (sCmd)

End Sub

'***************************************************************
'* Use the Sleep API call to put this thread to sleep
'***************************************************************
Sub Wait(byVal iSeconds as Integer)

	Call Sleep(iSeconds * 1000)

End Sub

Sub egsit
'***************************************************************
'* Exit the program
'***************************************************************

	End Program

End Sub
