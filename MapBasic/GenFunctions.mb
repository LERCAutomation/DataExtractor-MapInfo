'* DataExtractor is a MapInfo tool to extract biodiversity information
'* from SQL Server and MapInfo GIS layer for pre-defined spatial areas.
'*
'* Copyright Â© 2013 Greenspace Information for Greater London (GiGL)
'* 
'* This file is part of the MapInfo tool 'DataExtractor'.
'* 
'* DataExtractor is free software: you can redistribute it and/or modify
'* it under the terms of the GNU General Public License as published by
'* the Free Software Foundation, either version 3 of the License, or
'* (at your option) any later version.
'* 
'* DataExtractor is distributed in the hope that it will be useful,
'* but WITHOUT ANY WARRANTY; without even the implied warranty of
'* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'* GNU General Public License for more details.
'* 
'* You should have received a copy of the GNU General Public License
'* along with DataExtractor.  If not, see <http://www.gnu.org/licenses/>.
'*
'***************************************************************
'* GenFunctions v1.4
'*
'* Contains general functions used by the DataExtractor tool.
'*
'*
'* Created:			Andy Foy - February 2013
'* Last revised:	Andy Foy - April 2013
'***************************************************************
Include "DataExtractor.def"

Function TableIsOpen (ByVal sTabName As String) As Logical
'*************************************************
'* Check if the table is open
'*************************************************

	'-------------------------------------------------
	' Determine the number of open tables
	'-------------------------------------------------
	Dim iCounter, iNumberOfTables As Integer
	iNumberOfTables = NumTables()

	'-------------------------------------------------
	' Return FALSE if there are no open tables
	'-------------------------------------------------
	If iNumberOfTables = 0 Then
		TableIsOpen = FALSE
		Exit Function
	End If

	'-------------------------------------------------
	' Loop through the open tables looking for the
	' require table name. If found return TRUE
	'-------------------------------------------------
	For iCounter = 1 to iNumberOfTables
		If TableInfo(iCounter, TAB_INFO_NAME) = sTabName Then
			TableIsOpen = TRUE
			Exit Function
		End If
	Next

End Function

Function ExecuteAndWait(ByVal cmdLine as string) As Integer
'*************************************************
'* Execute a command and wait for it to finish
'*************************************************

	OnError Goto ErrorHandle

	Dim nRetVal As Integer, nExitCode As Integer
	Dim NameOfProc As Process_Information, NameStart As StartUpInfo
	Dim hProc As Integer

	NameStart.cb = 256
	NameStart.dwFlags = 1
	NameStart.wShowWindow = 0

	' Start the shelled application
	nRetVal = CreateProcessA(0, cmdLine, 0, 0, 1, NORMAL_PRIORITY_CLASS, 0, 0, NameStart, NameOfProc)

	' Get the handle of the started process
	hProc = NameOfProc.hProcess

	' Wait for the shelled application process to finish
	nRetVal = WaitForSingleObject(hProc, INFINITE)

	' Get the exit code from the shelled application
	nRetVal = GetExitCodeProcess(hProc, nExitCode)

	' Close the process handle
	nRetVal = CloseHandle(hProc)

	ExecuteAndWait = nExitCode

Exit Function

ErrorHandle:
	ExecuteAndWait = FALSE
	Note str$(Err()) + ": " + Error$()
	Call MyPrint(str$(Err()) + ": " + Error$())
	Exit Function

End Function

Function ZipFiles(sDefaultPath As String, sShortName As String) As Integer
'*************************************************
'* Zip all the files in the specified folder
'*************************************************

	Call MyPrint("Zipping the extract files ...")

	'-------------------------------------------------
	' Delete the zip file from the partner's subfolder
	' if it already exists
	'-------------------------------------------------
	If FileExists(sDefaultPath + "\" + sShortName + "\" + sShortName + ".zip") Then
		Call MyPrint("Deleting the existing zip file ...")
		Kill sDefaultPath + "\" + sShortName + "\" + sShortName + ".zip"
	End If

	'-------------------------------------------------
	' Create the zip command string
	'-------------------------------------------------
	Dim sZipCommand as string
	sZipCommand = "CScript.exe " +
		chr$(34) + ApplicationDirectory$() + "zip.vbs" + chr$(34) + " " + 
		chr$(34) + sDefaultPath + "\" + sShortName + chr$(34) + " " + 
		chr$(34) + sDefaultPath + "\" + sShortName + ".zip" + chr$(34) + " " + 
		"MOVE"

	'-------------------------------------------------
	' Execute the command and wait for it to finish
	'-------------------------------------------------
	Dim iZipSuccess As Integer
	iZipSuccess = ExecuteAndWait(sZipCommand)
	If iZipSuccess = 9 Then
		Call MyPrint("Error creating zip file - process interupted by user.")
		ZipFiles = iZipSuccess
		Exit Sub
	Else
		If iZipSuccess = 1 then
			Call MyPrint("No files to compress - zip process terminated.")
			ZipFiles = iZipSuccess
			Exit Sub
		Else
			If iZipSuccess > 0 then
				Call MyPrint("Error creating zip file - process terminated.")
				ZipFiles = iZipSuccess
				Exit Sub
			End if
		End If
	End if

	'-------------------------------------------------
	' Move zip file to the partner's subfolder
	'-------------------------------------------------
	Call MyPrint("Moving the zip file ...")

	Dim sOldFile, sNewFile As String
	sOldFile = sDefaultPath + "\" + sShortName + ".zip"
	sNewFile = sDefaultPath + "\" + sShortName + "\" + sShortName + ".zip"
	If MoveFile(sOldFile, sNewFile) = 0 then
		Call MyPrint("Error moving zip file - process terminated.")
		Call MyPrint("")
		ZipFiles = 99
		Exit Sub
	End if	

	ZipFiles = 0

End Function

Function STLText2Symbol(ByVal sSymbol As String) As Symbol
'*************************************************
'* Convert style text string to symbol
'*************************************************
Dim arrItems() As String, nNumItems As Integer
OnError GoTo ErrorOccured

nNumItems = StringSplit(sSymbol, ",", arrItems)

If nNumItems = 3 Then
	'MapInfo 3.0 symbol set
	STLText2Symbol = MakeSymbol(Val(arrItems(1)), Val(arrItems(2)), Val(arrItems(3)))
ElseIf nNumItems > 3 Then
	Do Case arrItems(1)
		Case "1"
			'MapInfo 3.0 symbol set
			STLText2Symbol = MakeSymbol(Val(arrItems(2)), Val(arrItems(3)), Val(arrItems(4)))
		Case "2"
			'TrueType font as the symbol
			STLText2Symbol = MakeFontSymbol(Val(arrItems(2)), Val(arrItems(3)), Val(arrItems(4)), arrItems(5), Val(arrItems(6)), Val(arrItems(7)))
		Case "3"
			'Symbol value based on a bitmap file
			STLText2Symbol = MakeCustomSymbol(arrItems(2), Val(arrItems(3)), Val(arrItems(4)), Val(arrItems(5)))
	End Case
End If

Exit Function
'-------------------------
ErrorOccured:
	STLText2Symbol = CurrentSymbol()
End Function

Function STLText2Pen(ByVal sSymbol As String) As Pen
'*************************************************
'* Convert style text string to pen
'*************************************************
Dim arrItems() As String, nNumItems As Integer
OnError GoTo ErrorOccured

nNumItems = StringSplit(sSymbol, ",", arrItems)

If nNumItems = 3 Then
	STLText2Pen = MakePen(Val(arrItems(1)), Val(arrItems(2)), Val(arrItems(3)))
End If

Exit Function
'-------------------------
ErrorOccured:
	STLText2Pen = CurrentPen()
End Function

Function STLText2Brush(ByVal sSymbol As String) As Brush
'*************************************************
'* Convert style text string to brush
'*************************************************
Dim arrItems() As String, nNumItems As Integer
OnError GoTo ErrorOccured

nNumItems = StringSplit(sSymbol, ",", arrItems)

If nNumItems = 2 Then
	STLText2Brush = MakeBrush(Val(arrItems(1)), Val(arrItems(2)), -1)
ElseIf nNumItems = 3 Then
	STLText2Brush = MakeBrush(Val(arrItems(1)), Val(arrItems(2)), Val(arrItems(3)))
End If

Exit Function
'-------------------------
ErrorOccured:
	STLText2Brush = CurrentBrush()
End Function

Function StringSplit(ByVal sText As String, ByVal sSplitChar As String, arrParts() As String) As Integer
'*************************************************
'* Splits a comma delimeted string into separate
'* values in an array
'*************************************************
	Dim sCopy As String, nBeg, nEnd As Integer, nCount As Integer 
	OnError GoTo ErrorOccured 
	nEnd = 0 
	nCount = 0 
	sCopy = UCase$(sText) 
	
	Do While nEnd <= Len(sCopy) 
		nBeg = nEnd + 1 
		nEnd = InStr(nBeg, sCopy, sSplitChar) 
		If nEnd = 0 Then 
			nEnd = Len(sCopy) + 1 
		End If 
		nCount = nCount + 1 
		ReDim arrParts(nCount) 
		If nBeg = nEnd Then 
			arrParts(nCount) = "" 
		Else 
			arrParts(nCount) = Mid$(sText, nBeg, nEnd - nBeg) 
		End If 
	Loop 
	STRINGSplit = nCount 

	Exit Function 
'------------------------- 
ErrorOccured: 
End Function
